<?php
/*
 * yzValidator contains the methods used by yzValidatorHelper to make normal
 * form or javascript tags into Client Side Validating ones
 * 
 * @author Yining Zhao
 * @package sfYzAjaxValidationPlugin
 */
class yzValidator
{
  /*
   * @var string Defines the name of the validation module that will validate
   * the form via AJAX request and send back the values via JSON
   */
  const VALIDATOR_MODULE = 'yzAjaxValidation';
  /*
   * Defines if the original tag to be written is an ajax remote function tag or
   * an normal form submit tag. It is used by createHiddenField_eval_onsuccess()
   * to create the hidden field that is evaluated on successful validation
   * Its value can be either :
   * 
   * ajax_remote_function
   * normal_submit
   * 
   * @see yzValidator::createHiddenField_eval_onsuccess()
   */
  private $form_submission_mode;
  private $hidden_validation_info_fields;
  /*
   * These are the ajax options that are normally run when the form is submited
   */
  private $options;
  /*
   * Instead of running the $options ajax options when submit is clicked.
   * $validation_options are run instead. Opon submit, the form makes an ajax
   * request to the Validator Module to do validation.
   */
  private $validation_options;
  private $options_html;
  /*
   * The html element Id for the eval_onsuccess hidden field
   * @see $eval_onsuccess_tag
   */
  private $eval_onsuccess_field_id;
  /*
   * Implementing client side validation requires the addition of a few extra
   * hidden fields. Just in case validation is applied in several different
   * places on the same page, we want to avoid having the same Id and Name for
   * the fields, so we append a random number to the end of its name
   */
  private $rand_tail;
  /*
   * This is the html for 2 hidden tags showing the action and module of the
   * original form action. This is needed by the validation module in choosing
   * the proper validator yml file to read
   */
  private $routeInfo_tags;
  /*
   * The $options ajax options that are usually activated when form is submited
   * is placed inside a hidden tag. It gets evaluated by JavaScript only when
   * the initial form submit to the Validator Module says there are no errors in
   * the validation
   */

  private $eval_onsuccess_tag;  

  function __construct($options = array(), $options_html = array(), $form_submission_mode)
  {
  	use_helper('Javascript');
    $options = _parse_attributes($options);
    $options_html = _parse_attributes($options_html);
    
    $this->form_submission_mode = $form_submission_mode;
    //If there are more than one yzValidator form or javascript helper on the page
    //we want to avoid having duplicate ids for the hidden fields that each one
    //generates. Thus we use $rand_tail ensure that the id of each hidden field
    //generated by yzValidation::yzSetupValidation() to be unique.
	if(isset($options['yzValidation_Id']))
	{
	  $this->rand_tail = $options['yzValidation_Id'];
	  unset($options['yzValidation_Id']);
	} else
	{
      $this->rand_tail = rand();
	}
    $this->setOptions($options);
    $this->options_html = $options_html;
    $this->initJS();
    $this->yzSetupValidation();
  }
   public function setOptions($options)
   {
     $this->options = $options;
   }
   public function getOptions()
   {
     return $this->options;
   }
   public function getRandTail()
   {
     return $this->rand_tail;
   }
   public function getOptionsHtml()
   {
     return $this->options_html;
   }
   public function setEvalOnSuccessFieldId()
   {
     $this->eval_onsuccess_field_id = 'yzValidator_eval_onsuccess'.$this->getRandTail();
   }
   public function getHiddenValidationInfoFields()
   {
     return $this->eval_onsuccess_tag.' '.$this->routeInfo_tags;
   }
  /*
   * This is the core function that changes the options and options_html so that
   * the form or javascript helper creates a tag that submits to yzValidator::
   * VALIDATOR_MODULE and calls the javascript function yzAV_JSONUpdater() once
   * it receives the JSON response
   * @return string in addition to altering the options array, it also returns
   * pertinant hidden fields that make the validation information run
   */
  public function yzSetupValidation()
  {
    //Sets the id of the eval_on_success hidden field 
    $this->setEvalOnSuccessFieldId();   
    $this->eval_onsuccess_tag = $this->createHiddenField_eval_onsuccess();
    $this->routeInfo_tags = $this->createHiddenField_route_info();
    $this->setValidationOptions();
  }
  public function getValidationOptions()
  {
    return $this->validation_options;
  }
  /*
   * Sets the validation options that will be used when the form submit is
   * activated. Wsers who are setting up the form or javascript
   * helpers in yzValidatorHelper class use the same syntax as the symfony
   * helpers of the same name. To can dictate how they want to from to appear
   * during the validation process, e. g. setting a busy signal when the form is
   * waiting on the JSON information from the validation, they would just add
   * the options with element key prefixed with 'yzValidation_'. For example:
   *
   *  <?php echo yzValidator form_remote_tag
   * ('Delete this post', array( 'update'=> 'feedback', 
   * 'url'=> 'post/delete?id='.$post->getId(), 
   * 'yzValidation_loading' => "Element.show('indicator_while_validating')",
   * 'yzValidation_complete'=> "Element. hide ('indicator_while_validating')",
   * 'loading' => "Element.show('indicator')", 'complete'=> "Element. hide
   * ('indicator')", )) ? >
   * 
   * In the above example, yzValidation_loading and yzValidation_complete show
   * that indicator when client validatoin is in progress. Only once validation
   * completes and the form is actually being submitted for real, are the
   * loading and complete options used.
   */
  protected function setValidationOptions()
  {
    //Gets the options that were set by user
    $options=$this->getOptions();
    //We will search through all of the keys of $options. Keys that start with
    //yzValidation_ are options for the AJAX validatoin request that occur after the user
    //clicks submit. These options will be transfered to yzVal_options and 
    //stricken from $options
    $options_keys = array_keys($options);
    
    for($i=0, $num_options = count($options);$i<$num_options;$i++)
    {
      $option_key = $options_keys[$i];
      
      if(strpos($option_key,'yzValidation_')=== 0 )
      {
        $exploded_key_ary = explode('yzValidation_',$option_key);
        $yzVal_option_key = $exploded_key_ary[1];
        //echo '$yzVal_option_key: '.$yzVal_option_key.'<br>';
        $options[$yzVal_option_key] .= $options[$option_key];
        //echo '$options[$option_key]: '.$options[$option_key].'<BR>';
        //echo '$option_key '.$option_key.'<BR><BR>';
        unset($options[$option_key]);
      } 
    }
    $options['url'] = yzValidator::VALIDATOR_MODULE;
    $eval_onsuccess_field_id = $this->eval_onsuccess_field_id;
    $options['complete'] = 'yzAV_JSONUpdater(request, json, '.$eval_onsuccess_field_id.');';
    unset($options['update']);

    //print_r($options);
    $this->validation_options = $options;
  }
  public function createHiddenField_route_info()
  {
    //Creates two hidden fields, one to contain action name and the other to contain
    //module name
    $options = $this->getOptions();
    $rand_tail = $this->rand_tail;
    $destination_uri = $options['url'];
    $routing_info = sfRouting::getInstance()->parse($destination_uri);
    //Check module to see if $destination url was a route name 
    //(e.g. @user_name) as opposed to a normal url (e.g user/name) because
    //in that case $routing_info['module'] would be the route name
    
    //If module was a route name, then it would have an @ sign in it
    $checkAtSign = explode('@',$routing_info['module']);
    if(count($checkAtSign)>1)
    {
      //Get action and module if $destination uri was a route name
      $routing_info = sfRouting::getInstance()->getRouteByName ($destination_uri);
      $routing_info = $routing_info[4];
    }
    $destination_action = $routing_info['action'];
    $destination_module = $routing_info['module'];
    //sfRouting::getInstance()->getRouteByName($destination_uri);
    $destination_action_tag = input_hidden_tag('yzValidator_destination_action', 
      $destination_action, "id='yzValidator_destination_action$rand_tail'");
    $destination_module_tag = input_hidden_tag('yzValidator_destination_module', 
      $destination_module, "id='yzValidator_destination_module$rand_tail'");
    $this->options = $options;
    return $destination_action_tag.' '.$destination_module_tag;
  }
  /*
   * 
   */
  public function createHiddenField_eval_onsuccess()
  {
    $elementId = $this->eval_onsuccess_field_id;
    $options = $this->options;
    if (!isset($options['with']))
    {
      $options['with'] = 'Form.serialize($("'.$elementId.'").form)';
    }
    //Creates a hidden field that holds the JS command to be called if
    //validation passes. This is the JS command that would originally have been called
    //when on submit was pressed, had we just used the default symfony helper
    switch($this->form_submission_mode)
    {
      //Trigger form.submit() if validation passes
      //This is used by the form helpers
      case 'normal_submit':
        $element_value = '$("'.$elementId.'").form.submit();'; 
        break;
      case 'ajax_remote_function':
        $element_value = remote_function($options);
        break;
    }

    $this->setOptions($options);
    return input_hidden_tag($elementId, $element_value);
    
  }
  /*
   * Loads the Javascript files necessary to run this class
   */
  protected function initJS()
  {
    
    sfContext::getInstance()->getResponse()->addJavascript(sfConfig::get('sf_prototype_web_dir').'/js/prototype');
    sfContext::getInstance()->getResponse()->addJavascript(sfConfig::get('sf_prototype_web_dir').'/js/effects');
    sfContext::getInstance()->getResponse()->addJavascript(sfConfig::get('sf_prototype_web_dir').'/js/builder');
    sfContext::getInstance()->getResponse()->addJavascript('/js/yzAjaxValidation/yzAjaxValidation');  
    }
  }
  ?>